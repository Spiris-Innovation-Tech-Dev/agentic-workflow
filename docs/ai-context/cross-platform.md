# Cross-Platform Architecture

This document describes how the agentic-workflow system works across all four AI host platforms (Claude Code, GitHub Copilot, Gemini CLI, OpenCode) and all operating system targets (Linux, WSL, macOS, native Windows).

For general architecture, see [architecture.md](./architecture.md). This document focuses on platform-specific patterns, fallbacks, and gotchas that arise from cross-platform support.

## Supported Matrix

| OS Environment | Claude Code | Copilot CLI | Gemini CLI | OpenCode |
|---|---|---|---|---|
| Linux (native) | Yes | Yes | Yes | Yes |
| macOS | Yes | Yes | Yes | Yes |
| WSL (file on ext4) | Yes | Yes | Yes | Yes |
| WSL (file on /mnt/) | Yes (slow) | Yes (slow) | Yes (slow) | Yes (slow) |
| Native Windows | Partial | Partial | Partial | Yes |

"Partial" on native Windows means the AI CLI itself may have limitations, but the agentic-workflow scripts handle Windows correctly (junctions, PowerShell, path handling).

## Four AI Host Platforms

### Platform Directory Mapping

Each AI host stores its configuration and agent files in a different directory:

| Platform | Global Config | Global Agents | Project Agents | MCP Config |
|---|---|---|---|---|
| Claude | `~/.claude/settings.json` | `~/.claude/agents/` | `.claude/agents/` | `~/.claude.json` (`mcpServers`) |
| Copilot | `~/.copilot/` | `~/.copilot/agents/` | `.github/agents/` | `~/.copilot/mcp-config.json` (`mcpServers`) |
| Gemini | `~/.gemini/settings.json` | `~/.gemini/agents/` | `.gemini/agents/` | `~/.gemini/settings.json` (`mcpServers`) |
| OpenCode | `~/.config/opencode/opencode.json` | `~/.config/opencode/agents/` | `.opencode/agents/` | `~/.config/opencode/opencode.json` (`mcp`) |

Command syntax per platform:

| Platform | Crew Start | Agent Reference | Commands |
|---|---|---|---|
| Claude | `/crew "task"` | Dispatched via Task tool | `/crew-worktree`, `/crew-status` |
| Copilot | `@crew "task"` | `@crew-architect`, etc. | Agent-based (no slash commands) |
| Gemini | `@crew-orchestrator "task"` | `@crew-architect`, etc. | Agent-based (no slash commands) |
| OpenCode | `/crew "task"` | `@crew-architect`, etc. | `/crew-worktree`, `/crew-status` |

### Resume Prompt Syntax

When a worktree session starts, it receives a resume prompt. The format varies by platform:

```
Claude:   /crew resume TASK_XXX
Copilot:  @crew-resume TASK_XXX
Gemini:   @crew-resume TASK_XXX
OpenCode: /crew-resume TASK_XXX
```

This is generated by `_build_resume_prompt()` in both `state_tools.py` and `setup-worktree.py`.

### Config Cascade Search Order

When loading `workflow-config.yaml`, the system searches platform directories in priority order:

```python
PLATFORM_DIRS = [".claude", ".copilot", ".gemini", ".config/opencode", ".opencode"]
```

For each cascade level (global `~/`, project `<repo>/`), the first directory found wins. This means a `.claude/workflow-config.yaml` takes precedence over `.gemini/workflow-config.yaml` at the same level.

## Platform Configuration Reference

Each platform has distinct conventions for MCP server registration, agent file format, and frontmatter fields. These differences are verified against official platform documentation and are critical when modifying installers or `build-agents.py`.

### MCP Server Registration

| Platform | Config File | Top-Level Key | Transport | Command Format | Env Key |
|---|---|---|---|---|---|
| Claude | `~/.claude.json` | `mcpServers` | `"type": "stdio"` (implicit) | `"command": "python3"` (string) | `"env"` |
| Copilot | `~/.copilot/mcp-config.json` | `mcpServers` | `"type": "stdio"` (implicit) | `"command": "python3"` (string) | `"env"` |
| Gemini | `~/.gemini/settings.json` | `mcpServers` | `"type": "stdio"` (implicit) | `"command": "python3"` (string) | `"env"` |
| OpenCode | `~/.config/opencode/opencode.json` | **`mcp`** (NOT `mcpServers`) | **`"type": "local"`** (NOT `"stdio"`) | **`"command": ["python3", "-m", "..."]`** (array, NOT string) | **`"environment"`** (NOT `"env"`) |

OpenCode is the outlier -- it uses different key names, transport types, and data formats for every field. See `install-opencode.sh` for the correct registration format.

### Agent File Format per Platform

| Platform | File Extension | Naming Convention | Frontmatter Format |
|---|---|---|---|
| Claude | `.md` | `architect.md` | None (plain markdown) |
| Copilot | **`.agent.md`** | `crew-architect.agent.md` | YAML with `name`, `description`, `tools` |
| Gemini | `.md` | `crew-architect.md` | YAML with `name`, `description`, `kind`, `tools`, `max_turns`, `timeout_mins` |
| OpenCode | `.md` | `crew-architect.md` | YAML with `description`, `mode`, `tools` |

### Agent Frontmatter Fields

**Claude Code** -- no frontmatter; agents are plain markdown files.

**Copilot** (`docs.github.com`):
```yaml
---
name: crew-architect           # Optional (filename used if omitted)
description: "..."             # REQUIRED
tools:
  - "*"                        # Only on orchestrator
---
```
No model selection (GitHub assigns the model).

**Gemini CLI** (`geminicli.com`):
```yaml
---
name: crew-architect
description: "..."
kind: local                    # local or remote
model: gemini-2.5-pro          # Per-agent model selection
tools:
  - read_file
  - search_file_content
max_turns: 30
timeout_mins: 10
---
```

**OpenCode** (`opencode.ai`):
```yaml
---
description: "..."
mode: subagent                 # primary (orchestrator) or subagent
model: ""                      # Optional: "provider/model-id" or "" to inherit default
tools:
  write: false                 # Boolean deny-map; omit to allow
  edit: false
  bash: false
permission:                    # Granular permission map (see Permissions below)
  edit: deny
  bash:
    "*": deny
    "git status*": allow
    "git log*": allow
---
```

OpenCode command agents use a different frontmatter:
```yaml
---
description: "..."
agent: build                   # or "read" for read-only commands
subtask: true
---
```

### build-agents.py Routing Logic

The build script routes output to different directories depending on whether the install is global (output_dir == `$HOME`) or project-level:

**`_copilot_agents_dir(output_dir)`**:
- Global (`$HOME`): `~/.copilot/agents/`
- Project (any other dir): `<output_dir>/.github/agents/`

**`_opencode_base(output_dir)`**:
- Global (`$HOME`): `~/.config/opencode/`
- Project (any other dir): `<output_dir>/.opencode/`

Claude and Gemini always use fixed paths:
- Claude: `<output_dir>/agents/` and `<output_dir>/commands/` (default output is `~/.claude/`)
- Gemini: `<output_dir>/.gemini/agents/` (default output is `$HOME`)

### Per-Agent Tool Restrictions

Each platform limits what tools sub-agents can use, defined in `build-agents.py`:

- **Claude**: No per-agent restrictions in frontmatter; orchestrator dispatches agents with appropriate instructions
- **Copilot**: No per-tool restrictions; orchestrator gets `tools: ["*"]`, sub-agents get no tools key
- **Gemini**: Explicit tool allowlists per agent (`GEMINI_AGENT_TOOLS` dict), plus `max_turns` limits (`GEMINI_MAX_TURNS`)
- **OpenCode**: Tool deny-maps per agent (`OPENCODE_AGENT_TOOLS` dict), e.g., `{"write": false, "edit": false}` to restrict read-only agents

### Per-Agent Model Selection

Platforms that support per-agent model selection use dicts in `build-agents.py` to map agent names to model IDs. The model is emitted in the agent frontmatter.

**Gemini** (`GEMINI_AGENT_MODELS`):

| Agent | Model | Rationale |
|---|---|---|
| architect, developer, reviewer, skeptic, implementer, feedback | `gemini-2.5-pro` | Complex reasoning |
| security-auditor, performance-analyst, api-guardian, orchestrator | `gemini-2.5-pro` | Complex reasoning |
| technical-writer, accessibility-reviewer | `gemini-2.0-flash` | Utility / simpler tasks |
| crew-worktree, crew-status | `gemini-2.0-flash` | Utility |

**OpenCode** (`OPENCODE_AGENT_MODELS`): All agents default to empty string (inherit from `opencode.json` default model). Users can override per-agent in their agent `.md` files or by editing the dict.

**Claude / Copilot**: No per-agent model selection in frontmatter. Claude uses the `models` section in `workflow-config.yaml`. Copilot uses the provider's default model.

### OpenCode Granular Permissions

OpenCode agents support a `permission:` block in frontmatter that provides fine-grained control over what each tool can do. This goes beyond the boolean `tools:` deny-map by allowing glob-pattern rules for Bash commands.

Defined in `build-agents.py` via `OPENCODE_AGENT_PERMISSIONS` dict and helper constants:

**Permission Profiles:**

| Profile | Used By | Description |
|---|---|---|
| `_READ_ONLY_BASH` | architect, developer, reviewer, skeptic, security-auditor, api-guardian, accessibility-reviewer, crew-status | Deny all bash by default, allow git read commands (status, log, diff, show, branch) and file inspection (grep, find, ls, cat, head, tail, wc, tree) |
| `_FEEDBACK_BASH` | feedback, performance-analyst | Extends `_READ_ONLY_BASH` with test execution (pytest, npm test, make test) |
| `_IMPLEMENTER_BASH` | implementer | Ask by default, allow git read + add + test commands, ask for git commit, deny git push and destructive commands (reset --hard, clean, rm -rf) |

**Permission Format:**

```yaml
permission:
  edit: deny                   # Simple tool-level permission
  webfetch: deny               # Block web access for read-only agents
  bash:                        # Glob-pattern rules for bash commands
    "*": deny                  # Default: deny all
    "git status*": allow       # Allow specific patterns
    "git log*": allow
```

Read-only agents (architect, developer, reviewer, skeptic) get `edit: deny`, `bash: _READ_ONLY_BASH`, and `webfetch: deny`. The implementer gets only `bash: _IMPLEMENTER_BASH` (all other tools allowed). The technical-writer gets `None` (tool-level restrictions only).

### Gemini thinkingConfig

The Gemini installer (`install-gemini.sh`) configures per-agent thinking budgets via `modelConfigs.overrides` in `~/.gemini/settings.json`. Each agent gets a `thinkingBudget` that controls how many tokens Gemini spends on internal reasoning.

**Budget Tiers:**

| Budget | Agents |
|---|---|
| 24576 (high) | architect, skeptic, security-auditor |
| 16384 (standard) | developer, reviewer, implementer, feedback, performance-analyst, api-guardian, orchestrator |
| 8192 (utility) | technical-writer, accessibility-reviewer |
| 4096 (command) | crew-worktree, crew-status |

**Settings Format** (in `~/.gemini/settings.json`):

```json
{
  "modelConfigs": {
    "overrides": [
      {
        "match": { "overrideScope": "crew-architect" },
        "modelConfig": {
          "generateContentConfig": {
            "thinkingConfig": { "thinkingBudget": 24576 }
          }
        }
      }
    ]
  }
}
```

The installer removes existing `crew-*` overrides before adding new ones, so re-running the installer is safe.

### Effort Level Mapping Across Platforms

The `effort_levels` section in `workflow-config.yaml` defines reasoning depth per agent per mode. How this maps differs by platform:

| Platform | Effort Mapping |
|---|---|
| Claude Code | `output_config.effort` (`low` / `medium` / `high` / `max`), combined with `thinking: {"type": "adaptive"}` |
| Gemini CLI | `thinkingConfig.thinkingBudget` in settings.json overrides (see table above) |
| OpenCode | Temperature (lower = more deterministic) |
| Copilot | Informational only (Copilot assigns its own model)

## Template Placeholder System

Agent source files in `agents/` and `commands/` use template placeholders that `scripts/build-agents.py` replaces at build time:

| Placeholder | Replaced With | Example |
|---|---|---|
| `{__platform__}` | Platform name string | `claude`, `copilot`, `gemini`, `opencode` |
| `{__platform_dir__}` | Platform config directory | `.claude`, `.copilot`, `.gemini`, `.opencode` |
| `{__scripts_dir__}` | Absolute path to scripts directory | `~/.claude/scripts`, `/home/user/agentic-workflow/scripts` |

### Build-Time Substitution

`_substitute_platform(content, platform)` in `build-agents.py` performs the replacement. The mappings are:

```python
PLATFORM_DIRS = {
    "claude": ".claude",
    "copilot": ".copilot",
    "gemini": ".gemini",
    "opencode": ".opencode",  # project-level; global uses .config/opencode/
}

SCRIPTS_DIRS = {
    "claude": "~/.claude/scripts",
    "copilot": str(REPO_ROOT / "scripts"),   # absolute repo path at build time
    "gemini": str(REPO_ROOT / "scripts"),    # absolute repo path at build time
    "opencode": str(REPO_ROOT / "scripts"),  # absolute repo path at build time
}
```

**Why `{__scripts_dir__}` exists**: Agent and command files reference helper scripts (e.g., `crew_orchestrator.py`, `cleanup-worktree.py`). When agents are installed globally (e.g., to `~/.claude/agents/`), the user's CWD is their project directory, not the agentic-workflow repo. Relative paths like `python3 scripts/crew_orchestrator.py` would fail with "No such file" errors. The placeholder is resolved at build time to an absolute path that works from any CWD.

For Claude, scripts are copied to `~/.claude/scripts/` by `install.sh`, so the placeholder resolves to that global location. For Copilot, scripts are bundled alongside agents (`.github/scripts/` for project-level, `~/.copilot/scripts/` for global) so agents work when deployed to any repo. For Gemini/OpenCode, the placeholder resolves to the agentic-workflow repo's absolute `scripts/` path at build time.

### Build Assertion

After all files are written, `_assert_no_raw_placeholders()` scans every generated `.md` file for un-substituted `{__platform__}`, `{__platform_dir__}`, or `{__scripts_dir__}` strings. If any remain, the build exits with code 1. This is a safety net to catch cases where agent content uses a placeholder but the substitution code missed it.

## Cross-Platform Fallback Patterns

The codebase uses a consistent pattern: try the preferred approach, fall back to a universally-available alternative.

### 1. Symlink/Junction Fallback (`setup-worktree.py`)

**Problem**: Worktrees need a `.tasks/` link to the main repo. Unix symlinks work everywhere on Unix, but on native Windows they require admin or developer-mode privileges.

**Solution**: `_symlink_or_junction(target, link)`

```
Platform check: not Windows?
  Yes → os.symlink(target, link)
  No  → try os.symlink(target, link)
         except OSError:
           _validate_path_for_cmd(target)  # Security check
           _validate_path_for_cmd(link)    # Security check
           cmd /c mklink /J link target    # NTFS junction
```

**Security**: Before invoking `cmd.exe`, `_validate_path_for_cmd()` checks that paths contain none of the cmd.exe metacharacters `& | < > ^ % "`. This prevents command injection through crafted directory names.

**Removal**: `_remove_symlink_or_junction(path)` uses `os.rmdir()` for junctions (not `os.unlink()` or `shutil.rmtree()`), because junctions are directory reparse points. `os.rmdir()` removes only the reparse point; `os.unlink()` or `shutil.rmtree()` would follow the junction and delete the target's actual contents.

### 2. Filelock Fallback (`crew_orchestrator.py`)

**Problem**: The `filelock` Python package may not be installed in all environments (especially lightweight containers or fresh Windows setups).

**Solution**: `_set_active_task()` and `_remove_active_task()`:

```python
try:
    from filelock import FileLock
    with FileLock(lock_path):
        write_file()
except ImportError:
    # Atomic write: tempfile.mkstemp() + os.replace()
    fd, tmp = tempfile.mkstemp(dir=tasks_dir, prefix=".active_task.tmp.")
    os.write(fd, data)
    os.close(fd)
    os.replace(tmp, target_path)  # Atomic on same filesystem
```

The `os.replace()` call is atomic on the same filesystem, so even without file locking the write is crash-safe. The only risk is a race condition between two concurrent writers, which `filelock` would prevent. The fallback logs a warning about this limitation.

### 3. Search Tool Fallback (`context_preparation.py`)

**Problem**: The `ag` (silver searcher) and `grep` command-line tools may not be available on all platforms, particularly on Windows.

**Solution**: `_search_files_python()` provides a pure-Python fallback:

```python
def _search_files_python(self, keyword: str) -> list[str]:
    """Pure-Python file search fallback."""
    # Walks the directory tree
    # Checks common code extensions (.py, .ts, .js, .go, .rs, etc.)
    # Skips known non-code dirs (node_modules, .git, __pycache__, etc.)
    # Returns up to 20 matching file paths
```

The fallback is used when both `ag` and `grep` are missing from PATH.

### 4. MCP Import Guard (`crew_orchestrator.py`)

**Problem**: The `crew_orchestrator.py` script imports from the MCP server package, but it can also be run standalone for testing.

**Solution**: MCP-dependent imports are wrapped in try/except with clear error messages indicating what to install.

### 5. YAML Parser Fallback (`setup-worktree.py`)

**Problem**: The `pyyaml` package may not be installed.

**Solution**: `_load_yaml()` falls back to a simple line-by-line `key: value` parser that handles booleans, integers, and strings. This covers the most common config cases without requiring the `yaml` module.

## PowerShell Encoding Pattern

### The Problem

On native Windows, launch commands must be executed via PowerShell. The traditional approach `powershell.exe -Command "script"` is fragile because:

- `$` signs trigger variable expansion
- Backticks are PowerShell escape characters
- Nested quotes require complex escaping
- User-provided text (task descriptions, paths) can break the command

### The Solution: `-EncodedCommand`

`_powershell_encoded_command(script)` in `setup-worktree.py`:

```python
def _powershell_encoded_command(script: str) -> str:
    encoded = base64.b64encode(script.encode('utf-16-le')).decode('ascii')
    return f'-EncodedCommand {encoded}'
```

This encodes the entire PowerShell script as Base64 UTF-16LE, which is the format PowerShell's `-EncodedCommand` parameter expects. The result is a single opaque string with no special characters — no escaping needed, no injection possible.

### Shell Quoting: `_shell_quote()`

For strings used *inside* the PowerShell script (before encoding), `_shell_quote(s, use_powershell=True)` wraps the string in single quotes with doubled internal single quotes:

```python
# Unix:       shlex.quote(s)        → 'hello world'
# PowerShell: "'" + s.replace("'", "''") + "'"  → 'hello world'
```

The `use_powershell` flag is set based on `terminal_env == "windows_native"`.

## WSL-Specific Handling

### Path Performance Detection

When running under WSL, paths on `/mnt/` (NTFS via the 9P filesystem bridge) are extremely slow for git operations. The system detects this:

```python
if is_wsl() and worktree_abs.startswith("/mnt/"):
    wsl_use_native = True
```

When `wsl_use_native` is True:
- Git commands are routed through `powershell.exe -Command "cd 'C:\...'; git ..."` to use native Windows git
- Dependency installation uses Windows-native commands (e.g., `python -m pip` instead of `pip`)
- Path conversion uses `wslpath -w` to translate WSL paths to Windows paths

### `is_wsl()` Detection

```python
def is_wsl() -> bool:
    with open("/proc/version") as f:
        return "microsoft" in f.read().lower()
```

This function exists in three places:
- `scripts/shared_utils.py` — The canonical version, used by most scripts
- `scripts/setup-worktree.py` — An inlined copy to keep the script standalone (no cross-script imports)
- `scripts/install-wt-colorschemes.py` — An inlined copy (standalone WSL-only helper)

If you change the detection logic, update all three locations.

### `fix-worktree-paths.py`

This script fixes `.git` pointer files in worktrees that live on Windows filesystems accessed from WSL. The `.git` file in a worktree contains a `gitdir:` line pointing to the main repo's `.git/worktrees/` directory. When the worktree is on `/mnt/`, this path needs special handling.

## Shared Utilities (`scripts/shared_utils.py`)

Extracted utility functions shared across multiple scripts:

| Function | Purpose | Used By |
|---|---|---|
| `is_wsl()` | Detect WSL environment via `/proc/version` | `fix-worktree-paths.py`, `cleanup-worktree.py` |
| `find_repo_root()` | Walk up from CWD to find `.git/` directory | `fix-worktree-paths.py`, `cleanup-worktree.py` |

**Important**: `setup-worktree.py` inlines its own copies of these functions rather than importing from `shared_utils.py`. This is intentional — `setup-worktree.py` must remain standalone because it may be run from environments where the scripts directory is not on the Python path. Keep the inlined versions in sync with `shared_utils.py`.

## Per-Platform Install and Uninstall

| Script | Platform | Purpose |
|---|---|---|
| `install.sh` | Claude (primary) | Main installer, also sets up worktree base directory permissions |
| `install-gemini.sh` | Gemini | Gemini-specific setup (trusted folders, agent build) |
| `install-copilot.sh` | Copilot | Copilot-specific setup (agents to `~/.copilot/agents/` + `.github/agents/`) |
| `install-opencode.sh` | OpenCode | OpenCode-specific setup (agents to `~/.config/opencode/agents/` + `.opencode/agents/`) |
| `uninstall.sh` | Claude | Removes Claude-specific files and MCP registration |
| `uninstall-copilot.sh` | Copilot | Removes Copilot-specific files from `~/.copilot/` and `.github/agents/` |
| `uninstall-gemini.sh` | Gemini | Removes Gemini-specific files |
| `uninstall-opencode.sh` | OpenCode | Removes OpenCode-specific files from `~/.config/opencode/` and `.opencode/` |

### Helper Scripts

| Script | Purpose |
|---|---|
| `scripts/gemini-trust.py` | Standalone helper to add a directory to `~/.gemini/trustedFolders.json` |
| `scripts/install-wt-colorschemes.py` | Installs crew color schemes into Windows Terminal `settings.json` |

## Claude Code Hooks

Claude Code supports lifecycle hooks that run scripts at specific points. The agentic-workflow system uses three hooks, configured via `config/hooks-settings.json` and merged into `~/.claude/settings.json` by the installer.

### Hook Architecture

```json
{
  "hooks": {
    "PreToolUse": [
      { "matcher": "Task",  "hooks": [{ "command": "validate-transition.py" }] },
      { "matcher": "Bash",  "hooks": [{ "command": "check-bash-safety.py" }] }
    ],
    "Stop": [
      { "hooks": [{ "command": "check-workflow-complete.py" }] }
    ]
  }
}
```

### Hook Details

| Hook | Trigger | Script | Behavior |
|---|---|---|---|
| **Transition Validator** | PreToolUse on `Task` | `scripts/validate-transition.py` | Validates that workflow phase transitions follow the correct sequence |
| **Bash Safety Gate** | PreToolUse on `Bash` | `scripts/check-bash-safety.py` | Warns (non-blocking) about destructive git commands, git push during workflows, git commit during planning phases |
| **Completion Checker** | Stop | `scripts/check-workflow-complete.py` | Blocks exit if workflow phases are incomplete; emits session-close reminders (uncommitted changes, open beads issues) when workflow is complete |

### Bash Safety Gate Details (`check-bash-safety.py`)

Session-isolated: only activates when a crew workflow is active (via `.active_task` file or worktree detection). Non-crew sessions are never affected.

**Destructive command warnings** (always warn during crew workflows):
- `git reset --hard`, `git clean -fd`, `git checkout .`, `git restore .`
- `git stash drop`, `git push --force`, `git branch -D`

**Context-aware warnings:**
- `git push` during active workflow (work should be merged locally, not pushed)
- `git commit` during planning phases (before implementer has run)

All warnings use `"decision": "warn"` — they inform but do not block.

### Enhanced Stop Hook Details (`check-workflow-complete.py`)

When the workflow IS complete, the stop hook checks for session-close protocol reminders:
- **Uncommitted changes**: Runs `git status --porcelain` and warns if files are modified
- **Open beads issues**: Runs `bd list --status=in_progress` and warns if issues remain open

These reminders use `"decision": "warn"` (non-blocking). Incomplete workflows use `"decision": "block"` to prevent premature exit.

### Hook Availability by Platform

| Hook Type | Claude | Copilot | Gemini | OpenCode |
|---|---|---|---|---|
| PreToolUse (Task) | Yes | No equivalent | No equivalent | No equivalent |
| PreToolUse (Bash) | Yes | No equivalent | No equivalent | Partial (via `permission:` block) |
| Stop | Yes | No equivalent | No equivalent | No equivalent |

OpenCode's `permission:` block provides similar protection to the Bash safety hook by restricting which commands agents can run, but it operates at the agent definition level rather than as a runtime hook.

## Claude Commands and OpenCode Commands

Commands (slash commands) are platform-specific entry points for workflow operations.

### Command Inventory

| Command | Claude | OpenCode | Purpose |
|---|---|---|---|
| `crew.md` | `/crew "task"` | `/crew "task"` | Main orchestrator entry point |
| `crew-config.md` | `/crew-config` | `/crew-config` | View/edit workflow configuration |
| `crew-resume.md` | `/crew-resume TASK_XXX` | `/crew-resume TASK_XXX` | Resume interrupted workflow |
| `crew-checkpoint.md` | `/crew-checkpoint [note]` | `/crew-checkpoint [note]` | Save manual workflow checkpoint with discovery |
| `crew-cost-report.md` | `/crew-cost-report [TASK_XXX]` | `/crew-cost-report [TASK_XXX]` | Display cost breakdown by agent/model |

Copilot and Gemini use agent-based invocation (`@crew "task"`, `@crew-resume TASK_XXX`) rather than slash commands.

### New Commands (TASK_016)

**`/crew-checkpoint`**: Saves a manual checkpoint of the current workflow state. Reads `.active_task`, loads `state.json`, calls `workflow_save_discovery` with category `decision` and the user's note (or auto-summary). Shows git status and suggests committing if changes exist.

**`/crew-cost-report`**: Displays a detailed cost breakdown for a task. Calls `workflow_get_cost_summary` and formats output as tables showing per-agent token usage, per-model costs, and mode comparison estimates.

### Copilot Delegation

The Copilot orchestrator (`config/platform-orchestrators/copilot.md`) includes guidance for delegating long implementations to GitHub's coding agent via `/delegate` or `&` prefix. This is useful when implementation has more than 15 steps or the user wants async execution. After delegation completes, the orchestrator resumes from where the coding agent left off.

## Adding Support for a New AI Host

If a 5th AI host platform needs to be added, update these locations:

1. **`scripts/build-agents.py`**: Add a `build_<platform>()` function, `PLATFORM_DIRS` entry, tool restrictions, and `PLATFORMS` registry entry
2. **`scripts/setup-worktree.py`**: Add to `AI_HOST_CLI`, `HOST_SETTINGS`, resume prompt logic in `build_resume_prompt()`
3. **`mcp/.../state_tools.py`**: Add to `_AI_HOST_CLI`, `_HOST_SETTINGS`, resume prompt in `_build_resume_prompt()`
4. **`config/platform-preambles/`**: Create `<platform>.md` preamble
5. **`config/platform-orchestrators/`**: Create `<platform>.md` orchestrator template (if the platform needs different orchestration instructions)
6. **`config/workflow-config.yaml`**: Update model mapping comments
7. **Installer/uninstaller**: Create `install-<platform>.sh` and/or `uninstall-<platform>.sh`
8. **`PLATFORM_DIRS` lists**: Update in `config_tools.py`, `setup-worktree.py`, and `build-agents.py` (these are inlined in multiple places — search for `PLATFORM_DIRS`)
